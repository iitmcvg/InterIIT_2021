# -*- coding: utf-8 -*-
"""occ_mask

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1A577xE7xKWrU05LQhMAt1ny_vpEueEjy
"""

# for i in range(48):
#   path='/content/'+'{}'.format('0'*(5-len(str(i))) + str(i))
#   images= os.listdir(path)
#   for img in images:
#     try:
#         image = Image.open(path + '/' +img)
#         image = image.resize((height,width))
#         image = np.array(image)
#         pathss.append(path + '/' +img)
#         data2.append(image)
#         labels2.append(int(i))
#     except:
#         print("Error in " + img)
# X_tests = np.array(data2)

wr_ci=[]
wr_cl=[]
wr_p=[]
for i in range(len(labels2)):
  if labels2[i]== pred[i]:
    wr_ci.append(X_pred[i])
    wr_cl.append(labels[i])
    wr_p.append(pathss[i])
len(wr_ci)

def occlusion(model, image, label, occ_size=50, occ_stride=50, occ_pixel=0.5):
    
    width, height = 224, 224

    output_height = int(np.ceil((height-occ_size)/occ_stride))
    output_width = int(np.ceil((width-occ_size)/occ_stride))
    
    heatmap = np.zeros((output_height, output_width))
    
    for h in range(0, height):
        for w in range(0, width):
            
            h_start = h*occ_stride
            w_start = w*occ_stride
            h_end = min(height, h_start + occ_size)
            w_end = min(width, w_start + occ_size)
            
            if (w_end) >= width or (h_end) >= height:
                continue
            input_image = np.copy(image)
            input_image[ w_start:w_end, h_start:h_end,:] = occ_pixel
            output= model.predict(input_image.reshape(1,224,224,3))
            prob= output[0][label]
            heatmap[h, w] = prob 

    return heatmap, max(output[0])

i=11
occ_image= wr_ci[i]
occ_label= wr_cl[i]
occ_path= wr_p[i]  #path of image

heatmap, prob_no_occ = occlusion(model, occ_image , occ_label , 14, 10)
imgplot = sns.heatmap(heatmap, xticklabels=False, yticklabels=False, vmax=prob_no_occ)

import cv2
def mask(heatmap):
  mask = heatmap < 1
  image = cv2.imread(occ_path)
  image = cv2.resize(image,mask.shape)
  mask = mask.astype('uint8')
  final = cv2.bitwise_and(image,image,mask = mask)
  plt.imshow(final)